# ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

## æ¦‚è¦

X Bookmarkerã®ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è²´é‡ãªãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«ç®¡ç†ã—ã€ä»–ã®ã‚µãƒ¼ãƒ“ã‚¹ã¨ã®ç›¸äº’é‹ç”¨æ€§ã‚’å®Ÿç¾ã—ã¾ã™ã€‚åŒ…æ‹¬çš„ãªã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ»ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã€è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ ã€ãã—ã¦çµ±åˆãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã‚ˆã‚Šã€ãƒ‡ãƒ¼ã‚¿ã®å¯æ¬æ€§ã¨å®‰å…¨æ€§ã‚’ä¿è¨¼ã—ã¾ã™ã€‚

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Data Management Architecture                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Export Service  â”‚ â”‚ Import Service  â”‚ â”‚ Backup Service  â”‚ â”‚
â”‚ â”‚ (Multi-format)  â”‚ â”‚ (Multi-source)  â”‚ â”‚ (Scheduled)     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ File Storage    â”‚ â”‚ Queue System    â”‚ â”‚ Validation      â”‚ â”‚
â”‚ â”‚ (S3/Local)      â”‚ â”‚ (Bull Queue)    â”‚ â”‚ Engine          â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚                    Storage Layer                        â”‚ â”‚
â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚ â”‚
â”‚ â”‚  â”‚ AWS S3      â”‚ â”‚ Local FS    â”‚ â”‚ Database        â”‚    â”‚ â”‚
â”‚ â”‚  â”‚ (Cloud)     â”‚ â”‚ (Dev/Test)  â”‚ â”‚ (Metadata)      â”‚    â”‚ â”‚
â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### 1. ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹

**ç›®çš„**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å¤šå½¢å¼ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã¨é…ä¿¡

**å®Ÿè£…å ´æ‰€**: `src/services/exportService.ts`

#### ã‚µãƒãƒ¼ãƒˆå½¢å¼

```typescript
export interface ExportOptions {
  format: 'json' | 'csv' | 'zip';           // å‡ºåŠ›å½¢å¼
  includeArchived?: boolean;                 // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å«ã‚€
  categoryIds?: string[];                    // ç‰¹å®šã‚«ãƒ†ã‚´ãƒªã®ã¿
  tags?: string[];                          // ç‰¹å®šã‚¿ã‚°ã®ã¿
  dateRange?: {                             // æœŸé–“æŒ‡å®š
    from: string;
    to: string;
  };
  compression?: boolean;                     // åœ§ç¸®ã‚ªãƒ—ã‚·ãƒ§ãƒ³
}
```

#### JSON ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

```typescript
// å®Œå…¨ãªæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
interface JsonExportStructure {
  metadata: {
    version: string;
    exportedAt: string;
    totalBookmarks: number;
    totalCategories: number;
  };
  categories: Category[];
  bookmarks: Bookmark[];
  settings: UserSettings;
}

async generateJsonExport(userId: string, options: ExportOptions): Promise<string> {
  const [bookmarks, categories, settings] = await Promise.all([
    this.getFilteredBookmarks(userId, options),
    this.getUserCategories(userId),
    this.getUserSettings(userId)
  ]);

  const exportData: JsonExportStructure = {
    metadata: {
      version: '1.0.0',
      exportedAt: new Date().toISOString(),
      totalBookmarks: bookmarks.length,
      totalCategories: categories.length
    },
    categories,
    bookmarks,
    settings
  };

  return JSON.stringify(exportData, null, 2);
}
```

#### CSV ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

```typescript
// CSVWriter ã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªå‡ºåŠ›
import createCsvWriter from 'csv-writer';

async generateCsvExport(bookmarks: Bookmark[]): Promise<string> {
  const csvWriter = createCsvWriter({
    path: this.tempFilePath,
    header: [
      { id: 'title', title: 'Title' },
      { id: 'url', title: 'URL' },
      { id: 'description', title: 'Description' },
      { id: 'categoryName', title: 'Category' },
      { id: 'tags', title: 'Tags' },
      { id: 'bookmarkedAt', title: 'Bookmarked Date' }
    ]
  });

  // ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã¨CSVå‡ºåŠ›
  const records = bookmarks.map(bookmark => ({
    title: bookmark.title || '',
    url: bookmark.url,
    description: bookmark.description || '',
    categoryName: bookmark.category?.name || 'Uncategorized',
    tags: bookmark.tags.join(', '),
    bookmarkedAt: bookmark.bookmarkedAt
  }));

  await csvWriter.writeRecords(records);
  return fs.readFileSync(this.tempFilePath, 'utf8');
}
```

#### ZIP ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

```typescript
// è¤‡æ•°å½¢å¼ã‚’å«ã‚€åŒ…æ‹¬çš„ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
import archiver from 'archiver';

async generateZipExport(userId: string, options: ExportOptions): Promise<Buffer> {
  const archive = archiver('zip', { zlib: { level: 9 } });
  
  // JSONãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
  const jsonData = await this.generateJsonExport(userId, options);
  archive.append(jsonData, { name: 'bookmarks.json' });
  
  // CSVãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
  const csvData = await this.generateCsvExport(bookmarks);
  archive.append(csvData, { name: 'bookmarks.csv' });
  
  // Chromeå½¢å¼ã®HTMLã‚’è¿½åŠ 
  const chromeHtml = await this.generateChromeBookmarks(bookmarks);
  archive.append(chromeHtml, { name: 'chrome_bookmarks.html' });
  
  // READMEã‚’è¿½åŠ 
  const readme = this.generateReadme(options);
  archive.append(readme, { name: 'README.txt' });
  
  archive.finalize();
  return archive;
}
```

### 2. ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹

**ç›®çš„**: å„ç¨®ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿å–ã‚Šè¾¼ã¿

**å®Ÿè£…å ´æ‰€**: `src/services/importService.ts`

#### ã‚µãƒãƒ¼ãƒˆã‚½ãƒ¼ã‚¹

```typescript
export type ImportSource = 
  | 'x-bookmarker'    // è‡ªèº«ã®JSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  | 'chrome'          // Chrome Bookmarks
  | 'firefox'         // Firefox JSON
  | 'twitter'         // Twitter Bookmarks  
  | 'csv'             // CSVå½¢å¼
  | 'json';           // æ±ç”¨JSON

export interface ImportOptions {
  source: ImportSource;
  duplicateStrategy: 'skip' | 'update' | 'create_duplicate';
  defaultCategory?: string;
  validate: boolean;
  dryRun: boolean;
}
```

#### Chrome ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

```typescript
// Chromeã®ãƒã‚¹ãƒˆã—ãŸæ§‹é€ ã‚’è§£é‡ˆ
interface ChromeBookmarkFolder {
  children: (ChromeBookmarkFolder | ChromeBookmark)[];
  date_added: string;
  date_modified: string;
  id: string;
  name: string;
  type: 'folder';
}

async parseChromeBookmarks(htmlContent: string): Promise<ParsedBookmark[]> {
  const $ = cheerio.load(htmlContent);
  const bookmarks: ParsedBookmark[] = [];
  
  const parseFolder = (element: cheerio.Element, categoryPath: string[] = []) => {
    $(element).find('> dt').each((_, dt) => {
      const $dt = $(dt);
      
      // ãƒ•ã‚©ãƒ«ãƒ€ã®å‡¦ç†
      if ($dt.find('> h3').length > 0) {
        const folderName = $dt.find('> h3').text();
        const newPath = [...categoryPath, folderName];
        const $dl = $dt.next('dl');
        if ($dl.length > 0) {
          parseFolder($dl[0], newPath);
        }
      }
      
      // ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã®å‡¦ç†
      else if ($dt.find('> a').length > 0) {
        const $link = $dt.find('> a');
        bookmarks.push({
          title: $link.text(),
          url: $link.attr('href') || '',
          description: '',
          category: categoryPath.join(' / ') || 'Imported',
          tags: [],
          addDate: new Date(parseInt($link.attr('add_date') || '0') * 1000)
        });
      }
    });
  };
  
  parseFolder($('dl')[0]);
  return bookmarks;
}
```

#### é‡è¤‡æ¤œå‡ºã¨ãƒãƒ¼ã‚¸æˆ¦ç•¥

```typescript
export class DuplicateResolver {
  async resolveDuplicates(
    newBookmarks: ParsedBookmark[],
    existingBookmarks: Bookmark[],
    strategy: DuplicateStrategy
  ): Promise<ImportResult> {
    const result: ImportResult = {
      imported: 0,
      updated: 0,
      skipped: 0,
      errors: []
    };

    for (const newBookmark of newBookmarks) {
      const duplicate = this.findDuplicate(newBookmark, existingBookmarks);
      
      if (!duplicate) {
        // æ–°è¦ä½œæˆ
        await this.createBookmark(newBookmark);
        result.imported++;
      } else {
        switch (strategy) {
          case 'skip':
            result.skipped++;
            break;
            
          case 'update':
            await this.updateBookmark(duplicate.id, newBookmark);
            result.updated++;
            break;
            
          case 'create_duplicate':
            await this.createBookmark({
              ...newBookmark,
              title: `${newBookmark.title} (Imported)`
            });
            result.imported++;
            break;
        }
      }
    }
    
    return result;
  }

  private findDuplicate(
    newBookmark: ParsedBookmark,
    existing: Bookmark[]
  ): Bookmark | null {
    // URLå®Œå…¨ä¸€è‡´
    let match = existing.find(b => b.url === newBookmark.url);
    if (match) return match;
    
    // ã‚¿ã‚¤ãƒˆãƒ« + ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸€è‡´
    const domain = this.extractDomain(newBookmark.url);
    match = existing.find(b => 
      b.title === newBookmark.title && 
      this.extractDomain(b.url) === domain
    );
    
    return match || null;
  }
}
```

### 3. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚µãƒ¼ãƒ“ã‚¹

**ç›®çš„**: çµ±ä¸€ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ»ãƒ­ãƒ¼ã‚«ãƒ«å¯¾å¿œ

**å®Ÿè£…å ´æ‰€**: `src/services/storageService.ts`

#### ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼æŠ½è±¡åŒ–

```typescript
export abstract class StorageProvider {
  abstract uploadFile(key: string, data: Buffer, contentType: string): Promise<string>;
  abstract downloadFile(key: string): Promise<Buffer>;
  abstract deleteFile(key: string): Promise<void>;
  abstract generateSignedUrl(key: string, expiresIn: number): Promise<string>;
  abstract listFiles(prefix: string): Promise<string[]>;
}

// AWS S3 ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
export class S3StorageProvider extends StorageProvider {
  private s3Client: S3Client;
  private bucketName: string;

  async uploadFile(key: string, data: Buffer, contentType: string): Promise<string> {
    const command = new PutObjectCommand({
      Bucket: this.bucketName,
      Key: key,
      Body: data,
      ContentType: contentType,
      ServerSideEncryption: 'AES256'
    });

    await this.s3Client.send(command);
    return `s3://${this.bucketName}/${key}`;
  }

  async generateSignedUrl(key: string, expiresIn: number): Promise<string> {
    const command = new GetObjectCommand({
      Bucket: this.bucketName,
      Key: key
    });

    return await getSignedUrl(this.s3Client, command, { expiresIn });
  }
}

// ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ  ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
export class LocalStorageProvider extends StorageProvider {
  private basePath: string;

  async uploadFile(key: string, data: Buffer): Promise<string> {
    const filePath = path.join(this.basePath, key);
    const dir = path.dirname(filePath);
    
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(filePath, data);
    
    return `file://${filePath}`;
  }

  async generateSignedUrl(key: string, expiresIn: number): Promise<string> {
    // ãƒ­ãƒ¼ã‚«ãƒ«ç”¨ã®æ™‚é™URLï¼ˆJWTãƒ™ãƒ¼ã‚¹ï¼‰
    const token = jwt.sign(
      { key, exp: Math.floor(Date.now() / 1000) + expiresIn },
      process.env.JWT_SECRET!
    );
    
    return `/api/files/download?token=${token}`;
  }
}
```

### 4. è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ 

**ç›®çš„**: å®šæœŸçš„ãªãƒ‡ãƒ¼ã‚¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨ç½å®³å¾©æ—§

**å®Ÿè£…å ´æ‰€**: `src/services/backupService.ts`

#### ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†

```typescript
export class BackupService {
  private schedules = new Map<string, cron.ScheduledTask>();

  startScheduledBackups(): void {
    const config = this.getBackupConfig();
    
    // æ—¥æ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ— (æ¯æ—¥2:00 AM)
    if (config.daily.enabled) {
      const dailyTask = cron.schedule('0 2 * * *', async () => {
        await this.performBackup('daily');
      }, { scheduled: false });
      
      this.schedules.set('daily', dailyTask);
      dailyTask.start();
    }
    
    // é€±æ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ— (æ—¥æ›œæ—¥3:00 AM) 
    if (config.weekly.enabled) {
      const weeklyTask = cron.schedule('0 3 * * 0', async () => {
        await this.performBackup('weekly');
      }, { scheduled: false });
      
      this.schedules.set('weekly', weeklyTask);
      weeklyTask.start();
    }
    
    // æœˆæ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ— (1æ—¥4:00 AM)
    if (config.monthly.enabled) {
      const monthlyTask = cron.schedule('0 4 1 * *', async () => {
        await this.performBackup('monthly');
      }, { scheduled: false });
      
      this.schedules.set('monthly', monthlyTask);
      monthlyTask.start();
    }
  }

  private async performBackup(type: BackupType): Promise<void> {
    console.log(`ğŸ—„ï¸ Starting ${type} backup...`);
    
    try {
      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å…¨ä½“ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      const dbBackup = await this.createDatabaseBackup();
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      const filesBackup = await this.createFilesBackup();
      
      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
      const metadata: BackupMetadata = {
        id: `${type}-${Date.now()}`,
        type,
        createdAt: new Date(),
        databaseSize: dbBackup.size,
        filesSize: filesBackup.size,
        totalSize: dbBackup.size + filesBackup.size
      };
      
      // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
      await this.storageService.uploadFile(
        `backups/${metadata.id}/database.sql`,
        dbBackup.data,
        'application/sql'
      );
      
      await this.storageService.uploadFile(
        `backups/${metadata.id}/files.tar.gz`,
        filesBackup.data,
        'application/gzip'
      );
      
      // å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      await this.cleanupOldBackups(type);
      
      console.log(`âœ… ${type} backup completed: ${metadata.id}`);
      
    } catch (error) {
      console.error(`âŒ ${type} backup failed:`, error);
      // ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡ï¼ˆå®Ÿè£…ä¾å­˜ï¼‰
      await this.sendBackupAlert(type, error);
    }
  }
}
```

#### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—

```typescript
async createDatabaseBackup(): Promise<BackupData> {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `backup-${timestamp}.sql`;
  
  try {
    // pg_dump ã‚’ä½¿ç”¨ã—ãŸåŒ…æ‹¬çš„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const dumpCommand = [
      'pg_dump',
      '--host', process.env.DATABASE_HOST,
      '--port', process.env.DATABASE_PORT,
      '--username', process.env.DATABASE_USER,
      '--dbname', process.env.DATABASE_NAME,
      '--verbose',
      '--clean',                    // DROPæ–‡ã‚’å«ã‚ã‚‹
      '--if-exists',               // ã‚¨ãƒ©ãƒ¼å›é¿
      '--create',                  // CREATE DATABASEæ–‡ã‚’å«ã‚ã‚‹
      '--format=plain',            // ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼
      '--encoding=UTF8'
    ].join(' ');
    
    const { stdout, stderr } = await execPromise(dumpCommand, {
      env: {
        ...process.env,
        PGPASSWORD: process.env.DATABASE_PASSWORD
      }
    });
    
    if (stderr && !stderr.includes('NOTICE')) {
      throw new Error(`pg_dump error: ${stderr}`);
    }
    
    const data = Buffer.from(stdout, 'utf8');
    
    return {
      filename,
      data,
      size: data.length,
      checksum: crypto.createHash('sha256').update(data).digest('hex')
    };
    
  } catch (error) {
    // pg_dump å¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: SQLç›´æ¥å®Ÿè¡Œ
    console.warn('pg_dump failed, falling back to SQL export:', error);
    return await this.createSqlBackup();
  }
}
```

## ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿æ¤œè¨¼

```typescript
export class DataValidator {
  validateImportData(data: any, source: ImportSource): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    
    // åŸºæœ¬æ§‹é€ æ¤œè¨¼
    if (!this.hasValidStructure(data, source)) {
      errors.push({
        type: 'INVALID_STRUCTURE',
        message: `Invalid ${source} data structure`
      });
    }
    
    // URLæ¤œè¨¼
    for (const bookmark of data.bookmarks || []) {
      if (!this.isValidUrl(bookmark.url)) {
        errors.push({
          type: 'INVALID_URL',
          message: `Invalid URL: ${bookmark.url}`,
          bookmark: bookmark.title
        });
      }
    }
    
    // ã‚µã‚¤ã‚ºåˆ¶é™
    const estimatedSize = JSON.stringify(data).length;
    if (estimatedSize > this.MAX_IMPORT_SIZE) {
      errors.push({
        type: 'SIZE_LIMIT_EXCEEDED',
        message: `Import data too large: ${estimatedSize} bytes`
      });
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      stats: this.generateStats(data)
    };
  }
  
  private isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
}
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

```typescript
// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
export class SecurityValidator {
  validateUploadedFile(file: Express.Multer.File): SecurityValidationResult {
    const checks = {
      fileSize: this.checkFileSize(file),
      mimeType: this.checkMimeType(file),
      content: this.scanContent(file),
      filename: this.validateFilename(file.originalname)
    };
    
    return {
      isSecure: Object.values(checks).every(check => check.passed),
      checks
    };
  }
  
  private scanContent(file: Express.Multer.File): SecurityCheck {
    const content = file.buffer.toString('utf8', 0, Math.min(file.size, 1024));
    
    // æ‚ªæ„ã®ã‚ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
    const maliciousPatterns = [
      /<script/i,
      /javascript:/i,
      /data:text\/html/i,
      /vbscript:/i
    ];
    
    const foundPatterns = maliciousPatterns.filter(pattern => 
      pattern.test(content)
    );
    
    return {
      passed: foundPatterns.length === 0,
      message: foundPatterns.length > 0 
        ? 'Potentially malicious content detected'
        : 'Content appears safe'
    };
  }
}
```

## UIçµ±åˆã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“

### ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã¨ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°

```typescript
// ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€²æ—è¡¨ç¤º
export const ImportProgress: React.FC<{ jobId: string }> = ({ jobId }) => {
  const [progress, setProgress] = useState<ImportProgress | null>(null);
  
  useEffect(() => {
    const eventSource = new EventSource(`/api/import/progress/${jobId}`);
    
    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setProgress(data);
    };
    
    eventSource.onerror = () => {
      eventSource.close();
    };
    
    return () => eventSource.close();
  }, [jobId]);
  
  if (!progress) return <div>Loading...</div>;
  
  return (
    <div className="space-y-4">
      <div className="flex justify-between text-sm">
        <span>{progress.currentStep}</span>
        <span>{progress.processed} / {progress.total}</span>
      </div>
      
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div 
          className="bg-blue-600 h-2 rounded-full transition-all duration-300"
          style={{ width: `${progress.percentage}%` }}
        />
      </div>
      
      {progress.errors.length > 0 && (
        <div className="text-red-600 text-sm">
          {progress.errors.length} errors occurred
        </div>
      )}
    </div>
  );
};
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†

```typescript
// å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†
export class StreamingProcessor {
  async processLargeImport(
    filePath: string, 
    source: ImportSource
  ): Promise<ImportResult> {
    const readStream = fs.createReadStream(filePath);
    const result: ImportResult = { imported: 0, errors: [], warnings: [] };
    
    return new Promise((resolve, reject) => {
      const processor = this.createProcessor(source);
      
      readStream
        .pipe(processor)
        .on('data', async (bookmark: ParsedBookmark) => {
          try {
            await this.processBookmark(bookmark);
            result.imported++;
          } catch (error) {
            result.errors.push({
              bookmark: bookmark.title,
              error: error.message
            });
          }
        })
        .on('end', () => resolve(result))
        .on('error', reject);
    });
  }
}
```

ã“ã®åŒ…æ‹¬çš„ãªãƒ‡ãƒ¼ã‚¿ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€X Bookmarkerã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è²´é‡ãªãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«ä¿è­·ã—ã€ä»–ã®ã‚µãƒ¼ãƒ“ã‚¹ã¨ã®ç›¸äº’é‹ç”¨æ€§ã‚’æä¾›ã—ã¾ã™ã€‚è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«ã‚ˆã‚Šç½å®³æ™‚ã®å¾©æ—§ã‚‚ä¿è¨¼ã—ã€ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã®ä¿¡é ¼æ€§ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚